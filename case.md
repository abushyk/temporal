# Кейс: Проектирование уведомительной системы

## Основные компоненты:

Модуль должен предоставлять наружу 2 перечисления для типов поддерживаемых каналов и типов сообщений
```
enum SendType {
	case Email;
	case Sms;
	case Push;
	case Telegram;
};

enum MessageType {
	case Service;
	case Entry;
	case Advertisment;
};
```
и интерфейс самого класса "сырого" сообщения
```
class NotifyDTO {
	send_type: SendType:тип //тип уведомления
	reciver: reciverID|reciverObj // ID получателя (допустим и объект получателя, но плохо, так как его даные могут потереять актуальность)
	data: mixed // либо структура, дающая возможность сформировать конечный текст, либо прямой текст
	lang: lang // указатель на язык (возможно эти данные можно получить из данных самого пользователя)
	message_type: MessageType:тип // тип самого сообщения (техническое, вход в систему, рекламное)
	retry_count: int
}
```
Можно использовать и простую структуру, но классом мы четче ограничим допустимын возможности поставляемые модулем

Вариант. Или предоставлять наружу сервис с интерфейсными методами push(), email(), sms() и тд которые будуь принимать адресата, сообщение, язык(?) и тип сообщения и внутри формировать нужную DTO, которую забрасывать в очередь или даже сразу слать на обработку. Тогда клиентам даже не нужно будет озадачиваться созданием ДТО и знанием о ней.

NotifyQueue - очередь для передачи в модуль данных о сообщениях от клиентских модулей.
interface NotifyQueue {
	public function next() : NotifyDTO;
	public function resend(NotifyDTO $NotifyDTO) : void;
}

NotifyDispatcher - обработчик очереди. извлекает сообщения, обрабатывает их.
MessageFormatter - форматировщик данных сообщения в "финальный" вид. применяет шаблонизацию, форматирование, учитывает требуемую локаль.
Состоит из абстрактного класса, умеющего создавать конкретные форматтеры
abstract class MessageFormatter {
	private $lang;
	private $template;
	public function __construct($lang){
		
	}
	
	public static function createFormatter(MessageType $messageType, $lang) : MessageFormatter{
		// по $messageType определяем какой именно форматтер нам нужен и создаем его
		return new AdvertismentFormatter($lang);
	}
	
	abstract public function format(mixed $data) : string{
		
	}
}

и конкретных форматтеров 
class AdvertismentFormatter extends MessageFormatter{
	private $template = 'какой-то конкретный шаблон для этого форматтера';
	public function format(mixed $data) : string{
		// форматируем рекламное сообщение согласно шаблона и языка
	}
}

NotifySender - отправщик уже сформатированного сообщения через соотвествующий канал связи.
Поддерживает интерфейс
interface NotifySender {
	public function send($target, $message) : bool;
}
который имплементируют отдельные отправщики
class EmailNotifySender implements NotifySender {
	public function send($target, $message) : bool {
		// отправка через почту
	}
}
а сами отправщики создаются классом NotifySenderCreator
class NotifySenderCreator{
	public static function create((SendType $sendType)) : NotifySender {
		// по $sendType определяем какой нужен отправщик и создаем его
		return new EmailNotifySender();
	}
}

NotifyLogger - логгер произощедшего. фиксирует в лог все "успешные" отправки. И "неуспешные" тоже.
interface NotifyLogger {
	public function log_error(NotifyDTO $NotifyDTO) : bool;
	public function log_success(NotifyDTO $NotifyDTO) : bool;
}

Я бы еще добавил некий класс-конфигруатор, который бы связал значения SendType и MessageType с именами классов конкретных реализаций этих сущностей и использовал бы именно его в фабриках NotifySenderCreator и MessageFormatter::createFormatter

====

Поставка уведомлений может производиться через некую очередь NotifyQueue. Данные об уведомлении умеют вид некторой структуры NotifyDTO, содержащей признак типа отправления, указателя на получателя и собственно данных уведомления.
NotifyDispatcher в одном или нескольких экземплярах обслуживает очередь. Его действия:
- получает очередную DTO
- получает данные пользователя и, из них, требуемый для данного сообщения адрес отправки (почта, номер телефона)
- отправляет данные сообщения в фабрику, которая по таким данным, как send_type и message_type определяет класс отправителя (NotifySender) и класс форматтера (MessageFormatter)
- если на этом этапе каких-то данных недостаточно для отправки (нет соотв. адреса в данных пользователя или неподдерживаемы тип message_type\send_type и нет заглущечных вариантов), то отправлять через NotifyLogger с признаком ошибки
- MessageFormatter форматирует данные о сообщении в текст по некоторому шаблону с учетом требуемого языка
- NotifySender пытается отправить собщение.
-- если NotifySender отдает положительный ответ и сообщение можно считать отправленым, то NotifyDispatcher отправляет его в NotifyLogger с признаком успеха. (либо в raw-формате в виде NotifyDTO, либо уже в обработанном и сокращенном - адресат, текст, канал)
-- если NotifySender отдает отрицательный ответ, то в зхависимости от конфигурации по необходимости и количеству ретраев, сверяемся со значением retry_count в NotifyDTO и при недостижении порогового значения наращиваем этот счетчик и отправляем сообщение обратно в NotifyQueue для повторной отправки
-- если NotifySender отдает отрицательный ответ и дальше, а переотправка более нецелесообразна, то сплавляем сообщение в NotifyLogger с признаком ошибки

=====

При росте нагрузки самым очевидным видится наразивание количества очередей и обработчиков. Но, поскольку узким местом будет, скорее всего, самая последжняя точка (физическа отправка на конечный адресат), то можно разделить этот модуль на два - на приемщика уведомлений из системы, который проведет разбор ДТО, форматирование самого сообзение, подбор адреса и толкать эту заготовку в следуюзую очередь, и на отправщика, который будет получать эти заготовки и просто отправлять. Тогда можно будет увеличивать пропускную способность только отправщиков, так как они будут запаздывать по сравнени. с приемщиками.

Так же можно использовать приоритизацию сообщений и менее приоритетные откладывать в отдельный буфер, который активировать либо в момент спада нагрузки, либо в промежутках, но малыми порциями.
